{
  "hash": "f275bdf3e048f17f4c452698d9db6e86",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In-class_Ex05\"\nauthor: \"Audrey Tan\"\ndate: \"17 May 2025\"\ndate-modified: \"last-modified\"\nformat: html\neditor: visual\nexecute: \n  eval: true\n  echo: true\n  warning: false \n  freeze: true\n---\n\nIn the code chunk below, p_load() of pacman package is used to load the R packages into R environment.\n\n::: panel-tabset\n## The Code\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse, jsonlite, SmartEDA, \n               tidygraph, ggraph, ggrepel)\n```\n:::\n\n:::\n\n## Importing Data\n\nFor the purpose of this exercise, *MC1_graph.json* file will be used. Before getting started, you should have the data set in the **data** sub-folder.\n\nIn the code chunk below, `fromJSON()` of **jsonlite** package is used to import *MC1_graph.json* file into R and save the output object\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvc1 <- fromJSON(\"data/MC1_graph.json\")\n```\n:::\n\n\n## Inspect Structure\n\nBefore preparing the data, it is always a good practice to examine the structure of *kg* object.\n\nIn the code chunk below `str()` is used to reveal the structure of *kg* object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(vc1, max.level =1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 5\n $ directed  : logi TRUE\n $ multigraph: logi TRUE\n $ graph     :List of 2\n $ nodes     :'data.frame':\t17412 obs. of  10 variables:\n $ links     :'data.frame':\t37857 obs. of  4 variables:\n```\n\n\n:::\n:::\n\n\nThis is a directed graph that is multigraph form.\n\n## Extract and Inspect\n\nNext, `as_tibble()` of **tibble** package package is used to extract the nodes and links tibble data frames from *kg* object into two separate tibble data frames called *nodes_tbl* and *edges_tbl* respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnodes_tbl<- as_tibble(vc1$nodes)\nedges_tbl<- as_tibble(vc1$links)\n```\n:::\n\n\n## Initial EDA for Nodes and Edges\n\nIt is time for us to apply appropriate EDA methods to examine the data.\n\nCode chunk below uses ggplot2 functions to reveal the frequency distribution of *Node Type* field of *nodes_tbl*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = nodes_tbl, \n       aes(y= `Node Type`))+\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](In-class_Ex05_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nggplot2 functions are used the reveal the frequency distribution of *Edge Type* field of *edges_tbl*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = edges_tbl,\n       aes(y=`Edge Type`))+\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](In-class_Ex05_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n## Knowledge Graph Creation\n\n### Step 1: Mapping from node id to row index\n\nBefore we can go ahead to build the tidygraph object, it is important for us to ensure each id from the node list is mapped to the correct row number. This requirement can be achieved by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nid_map <-tibble(id= nodes_tbl$id,\n                 index = seq_len(\n                   nrow(nodes_tbl)))\n```\n:::\n\n\n### Step 2: Map source and target IDs to row indices\n\nNext, we will map the source and the target IDs to row indices by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nedges_tbl <- edges_tbl%>%\n  left_join(id_map, by = c(\"source\"=\"id\"))%>%\n  rename(from = index)%>%\n  left_join(id_map, by = c(\"target\"=\"id\"))%>%\n  rename(to=index)\n```\n:::\n\n\n### Step 3: Filter out any unmatched (invalid) edges\n\nLastly, the code chunk below will be used to exclude the unmatch edges.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nedges_tbl <- edges_tbl %>%\n  filter(!is.na(from), !is.na(to))\n```\n:::\n\n\n### Step 4: Creating the graph\n\nCreated graph object by using code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph <- tbl_graph(nodes =nodes_tbl,\n                    edges =edges_tbl,\n                    directed =vc1$directed)\n```\n:::\n\n\nConfirm the output object is indeed in tidygraph format by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(graph)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_graph\" \"igraph\"   \n```\n\n\n:::\n:::\n\n\n## Visualising the knowledge graph\n\nIn this section, we will use ggraph’s functions to visualise and analyse the graph object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n```\n:::\n\n\nSeveral of the ggraph layouts involve randomisation. In order to ensure reproducibility, it is necessary to set the seed value before plotting by using the code chunk below.\n\n## Visualising the entire graph\n\nIn the code chunk below, ggraph functions are used to visualise the whole graph.\n\nPlotting the line is done before the node. Force directed layout applied.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(graph, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3, \n                 colour = \"gray\") +\n  geom_node_point(aes(color = `Node Type`), \n                  size = 2) +\n  geom_node_text(aes(label = name), \n                 repel = TRUE, \n                 size = 2.5) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](In-class_Ex05_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nNotice that the whole graph is very messy and we can hardy discover any useful patterns. This is always the case in graph visualisation and analysis. In order to gain meaningful visual discovery, it is always useful for us to looking into the details, for example by plotting sub-graphs.\n\n### Step 1: Filter edges to only \"Memberof\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph_memberof <- graph %>%\n  activate(edges) %>%\n  filter(`Edge Type`==\"MemberOf\")\n```\n:::\n\n\nFilter away the edges due to clutter from above.\n\n### Step 2: Extract only connected nodes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nused_node_indices <- graph_memberof %>%\n  activate(edges) %>%\n  as_tibble() %>%\n  select(from, to) %>%\n  unlist() %>%\n  unique()\n```\n:::\n\n\n### Step 3: Keep only those nodes\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph_memberof <- graph_memberof %>%\n  activate(nodes) %>%\n  mutate(row_id = row_number()) %>%\n  filter(row_id %in% used_node_indices) %>%\n  select(-row_id)  # optional cleanup\n```\n:::\n\n\n### Step 4: Plot the subgraph\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(graph_memberof, \n       layout = \"fr\") +\n  geom_edge_link(alpha = 0.5, \n                 colour = \"gray\") +\n  geom_node_point(aes(color = `Node Type`), \n                  size = 1) +\n  geom_node_text(aes(label = name), \n                 repel = TRUE, \n                 size = 2.5) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](In-class_Ex05_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\nNotice that the sub-graph above is very clear and the relationship between musical group and person can be visualise easily.\n",
    "supporting": [
      "In-class_Ex05_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}